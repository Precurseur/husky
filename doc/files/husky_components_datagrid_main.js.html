<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>husky_components/datagrid/main.js - husky</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="husky"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.1.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/AutoCompleteList.html">AutoCompleteList</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/husky_components_auto-complete-list.html">husky/components/auto-complete-list</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: husky_components/datagrid/main.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 *    Name: Datagrid
 *
 *    Options:
 *      - autoRemoveHandling: raises an event before a row is removed
 *      - className: additional classname for the wrapping div
 *      - data: array of data to display (instead of using a url)
 *      - elementType: type of datagrid (currently is only table available)
 *      - excludeFields: array of field to exclude
 *      - pagination: display a pagination
 *      - pageSize: lines per page
 *      - showPages: amount of pages that will be shown
 *      - removeRow: displays in the last column an icon to remove a row
 *      - selectItem.type: typ of select [checkbox, radio]
 *      - selectItem.width: typ of select [checkbox, radio]
 *      - sortable: is list sortable [true,false]
 *      - tableHead: configuration of table header
 *          - content: column title
 *          - width: width of column
 *          - class: css class of th
 *          - attribute: mapping information to data (if not set it will just itterate of attributes)
 *      - url: url to fetch content
 *      - appendTBody: add TBODY to table
 *
 *    Provided Events:
 *       - husky.datagrid.item.deselect - raised when item is deselected
 *       - husky.datagrid.item.select - raised when item is selected
 *       - husky.datagrid.all.deselect - raised when all items get deselected via the header checkbox
 *       - husky.datagrid.all.select - raised when all items get selected via the header checkbox
 *       - husky.datagrid.row.remove-click - raised when clicked on the remove-row-icon
 *       - husky.datagrid.row.removed - raised when row got removed
 *       - husky.datagrid.page.change - raised when the the current page changes
 *       - husky.datagrid.updated - raised when the data is updated
 *       - husky.datagrid.item.click - raised when clicked on an item
 *       - husky.datagrid.items.selected - raised when husky.datagrid.items.get-selected is triggered
 *       - husky.datagrid.data.provide - raised when when husky.datagrid.data.get is triggered
 *
 *
 *    Used Events:
 *       - husky.datagrid.update - used to trigger an update of the data
 *       - husky.datagrid.row.add - used to add a row
 *       - husky.datagrid.row.remove - used to remove a row
 *       - husky.datagrid.items.get-selected - triggers husky.datagrid.items.selected event, which returns all selected item ids
 *       - husky.datagrid.data.get - triggers husky.datagrid.data.provide
 *
 */



define(function() {

    &#x27;use strict&#x27;;

    /**
     *    Default values for options
     */
    var defaults = {
        autoRemoveHandling: true,
        className: &#x27;datagridcontainer&#x27;,
        elementType: &#x27;table&#x27;,
        data: null,
        defaultMeasureUnit: &#x27;px&#x27;,
        excludeFields: [&#x27;id&#x27;],
        pagination: false,
        paginationOptions: {
            pageSize: 4,
            showPages: 5
        },
        removeRow: true,
        selectItem: {
            type: null,      // checkbox, radiobutton
            width: &#x27;50px&#x27;    // numerous value
            //clickable: false   // defines if background is clickable TODO do not use until fixed
        },
        sortable: false,
        tableHead: [],
        url: null,
        appendTBody: true   // add TBODY to table
    };


    return {

        view: true,

        initialize: function() {
            this.sandbox.logger.log(&#x27;initialized datagrid&#x27;);

            // extend default options and set variables
            this.options = this.sandbox.util.extend(true, {}, defaults, this.options);
            this.name = this.options.name;
            this.data = null;
            this.allItemIds = [];
            this.selectedItemIds = [];
            this.rowStructure = [&#x27;id&#x27;];
            this.sort = {
                ascClass: &#x27;icon-arrow-up&#x27;,
                descClass: &#x27;icon-arrow-down&#x27;,
                additionalClasses: &#x27; m-left-5 small-font&#x27;
            };

            // append datagrid to html element
            this.$originalElement = this.sandbox.dom.$(this.options.el);
            this.$element = this.sandbox.dom.$(&#x27;&lt;div class=&quot;husky-datagrid&quot;/&gt;&#x27;);
            this.$originalElement.append(this.$element);

            this.getData();

            // Should only be be called once
            this.bindCustomEvents();
        },

        /**
         * Gets the data either via the url or the array
         */
        getData: function() {

            if (!!this.options.url) {

                this.sandbox.logger.log(&#x27;load data from url&#x27;);
                this.load({ url: this.options.url});

            } else if (!!this.options.data.items) {

                this.sandbox.logger.log(&#x27;load data from array&#x27;);
                this.data = this.options.data;

                this.prepare()
                    .appendPagination()
                    .render();
            }
        },

        /**
         * Loads contents via ajax
         * @param params url
         */
        load: function(params) {

            this.sandbox.util.ajax({

                url: this.getUrl(params),
                data: params.data,

                error: function(jqXHR, textStatus, errorThrown) {
                    this.sandbox.logger.log(&quot;An error occured while fetching data from: &quot; + this.getUrl(params));
                    this.sandbox.logger.log(&quot;textstatus: &quot;+textStatus);
                    this.sandbox.logger.log(&quot;errorthrown&quot;,errorThrown);
                }.bind(this),

                success: function(response) {

                    // TODO adjust when new api is finished and no backwards compatibility needed
                    if(!!response.items) {
                        this.data = response;
                    } else {
                        this.data = {};
                        this.data.links = response._links;
                        this.data.embedded = response._embedded;
                        this.data.total = response.total;
                        this.data.page = response.page;
                        this.data.pages = response.pages;
                        this.data.pageSize = response.pageSize || this.options.paginationOptions.pageSize;
                        this.data.pageDisplay = this.options.paginationOptions.showPages;
                    }

                    this.prepare()
                        .appendPagination()
                        .render();

                    this.setHeaderClasses();

                    if (typeof params.success === &#x27;function&#x27;) {
                        params.success(response);
                    }
                }.bind(this)
            });
        },

        /**
         * Returns url with page size and page param at the end
         * @param params
         * @returns {string}
         */
        getUrl: function(params) {

            // TODO adjust when new api is finished and no backwards compatibility needed
            if (!!this.data &amp;&amp; this.data.links) {
                return params.url;
            }

            var delimiter = &#x27;?&#x27;, url;
            if (params.url.indexOf(&#x27;?&#x27;) !== -1) {
                delimiter = &#x27;&amp;&#x27;;
            }

            url = params.url + delimiter + &#x27;pageSize=&#x27; + this.options.paginationOptions.pageSize;
            if (params.page &gt; 1) {
                url += &#x27;&amp;page=&#x27; + params.page;
            }

            return url;
        },

        /**
         * Prepares the structure of the datagrid (list, table)
         * @returns {*}
         */
        prepare: function() {
            this.$element.empty();

            if (this.options.elementType === &#x27;list&#x27;) {
                // TODO:
                //this.$element = this.prepareList();
                this.sandbox.logger.log(&quot;list is not yet implemented!&quot;);
            } else {
                this.$element.append(this.prepareTable());
            }

            return this;
        },

        /**
         * Perapres the structure of the datagrid when element type is table
         * @returns {table} returns table element
         */
        prepareTable: function() {
            var $table, $thead, $tbody, tblClasses;

            $table = this.sandbox.dom.$(&#x27;&lt;table/&gt;&#x27;);

            if (!!this.data.head || !!this.options.tableHead) {
                $thead = this.sandbox.dom.$(&#x27;&lt;thead/&gt;&#x27;);
                $thead.append(this.prepareTableHead());
                $table.append($thead);
            }

            // TODO adjust when api is fully implemented and no backwards compatibility needed
            if (!!this.data.items || !!this.data.embedded) {
                if (!!this.options.appendTBody) {
                    $tbody = this.sandbox.dom.$(&#x27;&lt;tbody/&gt;&#x27;);
                }
                $tbody.append(this.prepareTableRows());
                $table.append($tbody);
            }

            // set html classes
            tblClasses = [];
            tblClasses.push((!!this.options.className &amp;&amp; this.options.className !== &#x27;table&#x27;) ? &#x27;table &#x27; + this.options.className : &#x27;table&#x27;);
            tblClasses.push((this.options.selectItem &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) ? &#x27;is-selectable&#x27; : &#x27;&#x27;);

            $table.addClass(tblClasses.join(&#x27; &#x27;));

            return $table;
        },

        /**
         * Prepares table head
         * @returns {string} returns table head
         */

        prepareTableHead: function () {
            var tblColumns, tblCellClass, tblColumnWidth, headData, tblCheckboxWidth, widthValues, checkboxValues, dataAttribute, isSortable;

            tblColumns = [];
            headData = this.options.tableHead || this.data.head;

            // add a checkbox to head row
            if (!!this.options.selectItem &amp;&amp; this.options.selectItem.type) {

                // default values
                checkboxValues = [];
                if (this.options.selectItem.width) {
                    checkboxValues = this.getNumberAndUnit(this.options.selectItem.width, this.options.defaultMeasureUnit);
                }

                tblCheckboxWidth = [];
                tblCheckboxWidth.push(
                    &#x27;width =&#x27;,
                    checkboxValues[0],
                    checkboxValues[1]
                );


                tblColumns.push(
                    &#x27;&lt;th class=&quot;select-all&quot; &#x27;, tblCheckboxWidth.join(&quot;&quot;), &#x27; &gt;&#x27;);

                if (this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    tblColumns.push(this.templates.checkbox({ id: &#x27;select-all&#x27; }));
                }

                tblColumns.push(&#x27;&lt;/th&gt;&#x27;);
            }

            this.rowStructure = [&#x27;id&#x27;];

            headData.forEach(function (column) {

                tblColumnWidth = &#x27;&#x27;;
                // get width and measureunit
                if (!!column.width) {
                    widthValues = this.getNumberAndUnit(column.width, this.options.defaultMeasureUnit);
                    tblColumnWidth = &#x27; width=&quot;&#x27; + widthValues[0] + widthValues[1] + &#x27;&quot;&#x27;;
                }

                isSortable = false;

                // TODO adjust when new api fully implemented and no backwards compatibility needed
                if(!!this.data.links &amp;&amp; !!this.data.links.sortable) {

                    //is column sortable - check with received sort-links
                    this.sandbox.util.each(this.data.links.sortable, function(index) {
                        if(index === column.attribute){
                            isSortable = true;
                            return false;
                        }
                    }.bind(this));
                }

                // add to row structure when valid entry
                if(column.attribute !== undefined) {
                    this.rowStructure.push(column.attribute);
                }

                // add html to table header cell if sortable
                if (!!isSortable) {
                    dataAttribute = &#x27; data-attribute=&quot;&#x27; + column.attribute + &#x27;&quot;&#x27;;
                    tblCellClass = ((!!column.class) ? &#x27; class=&quot;&#x27; + column.class + &#x27; pointer&quot;&#x27; : &#x27; class=&quot;pointer&quot;&#x27;);
                    tblColumns.push(&#x27;&lt;th&#x27; + tblCellClass + tblColumnWidth + dataAttribute + &#x27;&gt;&#x27; + column.content + &#x27;&lt;span&gt;&lt;/span&gt;&lt;/th&gt;&#x27;);
                } else {
                    tblCellClass = ((!!column.class) ? &#x27; class=&quot;&#x27; + column.class + &#x27;&quot;&#x27; : &#x27;&#x27;);
                    tblColumns.push(&#x27;&lt;th&#x27; + tblCellClass + tblColumnWidth + &#x27;&gt;&#x27; + column.content + &#x27;&lt;/th&gt;&#x27;);
                }

            }.bind(this));

            return &#x27;&lt;tr&gt;&#x27; + tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;;
        },

        // returns number and unit
        getNumberAndUnit: function(numberUnit, defaultUnit) {
            numberUnit = String(numberUnit);
            var regex = numberUnit.match(/(\d+)\s*(.*)/);
            // no unit , set default
            if ((!!defaultUnit) &amp;&amp; (!regex[2])) {
                regex[2] = defaultUnit;
            }
            return [regex[1], regex[2]];
        },

        /**
         * Itterates over all items and prepares the rows
         * @returns {string} returns a string of all rows
         */
        prepareTableRows: function() {
            var tblRows;

            tblRows = [];
            this.allItemIds = [];

            // TODO adjust when new api is fully implemented and no backwards compatibility needed
            if(!!this.data.items) {
                this.data.items.forEach(function (row) {
                    tblRows.push(this.prepareTableRow(row));
                }.bind(this));
            } else if(!!this.data.embedded) {
                this.data.embedded.forEach(function (row) {
                    tblRows.push(this.prepareTableRow(row));
                }.bind(this));
            }

            return tblRows.join(&#x27;&#x27;);
        },

        /**
         * Returns a table row including values and data attributes
         * @param row
         * @returns string table row
         */
        prepareTableRow: function(row) {

            if (!!(this.options.template &amp;&amp; this.options.template.row)) {

                return this.sandbox.template.parse(this.options.template.row, row);

            } else {

                var radioPrefix, key;
                this.tblColumns = [];
                this.tblRowAttributes = &#x27;&#x27;;

                if (!!this.options.className &amp;&amp; this.options.className !== &#x27;&#x27;) {
                    radioPrefix = &#x27;-&#x27; + this.options.className;
                } else {
                    radioPrefix = &#x27;&#x27;;
                }

                !!row.id &amp;&amp; this.allItemIds.push(parseInt(row.id, 10));

                if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                    // add a checkbox to each row
                    this.tblColumns.push(&#x27;&lt;td&gt;&#x27;, this.templates.checkbox(), &#x27;&lt;/td&gt;&#x27;);
                } else if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;radio&#x27;) {
                    // add a radio to each row

                    this.tblColumns.push(&#x27;&lt;td&gt;&#x27;, this.templates.radio({
                        name: &#x27;husky-radio&#x27; + radioPrefix
                    }), &#x27;&lt;/td&gt;&#x27;);
                }

                // when row structure contains more elements than the id then use the structure to set values
                if (this.rowStructure.length &gt; 1) {
                    this.rowStructure.forEach(function(key) {
                        this.setValueOfRowCell(key, row[key]);
                    }.bind(this));
                } else {
                    for (key in row) {
                        if (row.hasOwnProperty(key)) {
                            this.setValueOfRowCell(key, row[key]);
                        }
                    }
                }

                if (!!this.options.removeRow) {
                    this.tblColumns.push(&#x27;&lt;td class=&quot;remove-row&quot;&gt;&#x27;, this.templates.removeRow(), &#x27;&lt;/td&gt;&#x27;);
                }

                return &#x27;&lt;tr&#x27; + this.tblRowAttributes + &#x27;&gt;&#x27; + this.tblColumns.join(&#x27;&#x27;) + &#x27;&lt;/tr&gt;&#x27;;
            }
        },

        /**
         * Sets the value of row cell and the data-id attribute for the row
         * @param key attribute name
         * @param value attribute value
         */
        setValueOfRowCell: function(key, value) {
            var tblCellClasses,
                tblCellContent,
                tblCellClass;

            if (this.options.excludeFields.indexOf(key) &lt; 0) {
                tblCellClasses = [];
                tblCellContent = (!!value.thumb) ? &#x27;&lt;img alt=&quot;&#x27; + (value.alt || &#x27;&#x27;) + &#x27;&quot; src=&quot;&#x27; + value.thumb + &#x27;&quot;/&gt;&#x27; : value;

                // prepare table cell classes
                !!value.class &amp;&amp; tblCellClasses.push(value.class);
                !!value.thumb &amp;&amp; tblCellClasses.push(&#x27;thumb&#x27;);

                tblCellClass = (!!tblCellClasses.length) ? &#x27;class=&quot;&#x27; + tblCellClasses.join(&#x27; &#x27;) + &#x27;&quot;&#x27; : &#x27;&#x27;;

                this.tblColumns.push(&#x27;&lt;td &#x27; + tblCellClass + &#x27; &gt;&#x27; + tblCellContent + &#x27;&lt;/td&gt;&#x27;);
            } else {
                this.tblRowAttributes += &#x27; data-&#x27; + key + &#x27;=&quot;&#x27; + value + &#x27;&quot;&#x27;;
            }
        },

        /**
         * Resets the arrays for selected items
         */
        resetItemSelection: function() {
            this.allItemIds = [];
            this.selectedItemIds = [];
        },

        /**
         * Selectes or deselects the clicked item
         * @param event
         */
        selectItem: function(event) {

            // Todo review handling of events for new rows in datagrid (itemId empty?)

            var $element, itemId, oldSelectionId;

            $element = this.sandbox.dom.$(event.currentTarget);

            if (!$element.is(&#x27;input&#x27;)) {
                $element = $element.parent().find(&#x27;input&#x27;);
            }

            itemId = $element.parents(&#x27;tr&#x27;).data(&#x27;id&#x27;);

            if ($element.attr(&#x27;type&#x27;) === &#x27;checkbox&#x27;) {

                if (this.selectedItemIds.indexOf(itemId) &gt; -1) {
                    $element
                        .removeClass(&#x27;is-selected&#x27;)
                        .prop(&#x27;checked&#x27;, false);

                    // uncheck &#x27;Select All&#x27;-checkbox
                    $(&#x27;th.select-all&#x27;)
                        .find(&#x27;input[type=&quot;checkbox&quot;]&#x27;)
                        .prop(&#x27;checked&#x27;, false);

                    this.selectedItemIds.splice(this.selectedItemIds.indexOf(itemId), 1);
                    this.sandbox.emit(&#x27;husky.datagrid.item.deselect&#x27;, itemId);
                } else {
                    $element
                        .addClass(&#x27;is-selected&#x27;)
                        .prop(&#x27;checked&#x27;, true);

                    if (!!itemId) {
                        this.selectedItemIds.push(itemId);
                        this.sandbox.emit(&#x27;husky.datagrid.item.select&#x27;, itemId);
                    } else {
                        this.sandbox.emit(&#x27;husky.datagrid.item.select&#x27;, event);
                    }
                }

            } else if ($element.attr(&#x27;type&#x27;) === &#x27;radio&#x27;) {

                oldSelectionId = this.selectedItemIds.pop();

                if (!!oldSelectionId &amp;&amp; oldSelectionId &gt; -1) {
                    this.sandbox.dom.$(&#x27;tr[data-id=&quot;&#x27; + oldSelectionId + &#x27;&quot;]&#x27;).find(&#x27;input[type=&quot;radio&quot;]&#x27;).removeClass(&#x27;is-selected&#x27;).prop(&#x27;checked&#x27;, false);
                    this.sandbox.emit(&#x27;husky.datagrid.item.deselect&#x27;, oldSelectionId);
                }

                $element.addClass(&#x27;is-selected&#x27;).prop(&#x27;checked&#x27;, true);

                if (!!itemId) {
                    this.selectedItemIds.push(itemId);
                    this.sandbox.emit(&#x27;husky.datagrid.item.select&#x27;, itemId);
                } else {
                    this.sandbox.emit(&#x27;husky.datagrid.item.select&#x27;, event);
                }

            }
        },

        /**
         * Selects or deselect all available items of the list
         * @param event
         */
        selectAllItems: function(event) {

            event.stopPropagation();
            if (this.sandbox.util.compare(this.selectedItemIds, this.allItemIds)) {

                this.$element
                    .find(&#x27;input[type=&quot;checkbox&quot;]&#x27;)
                    .prop(&#x27;checked&#x27;, false);

                this.selectedItemIds = [];
                this.sandbox.emit(&#x27;husky.datagrid.all.deselect&#x27;, null);

            } else {
                this.$element
                    .find(&#x27;input[type=&quot;checkbox&quot;]&#x27;)
                    .prop(&#x27;checked&#x27;, true);

                this.selectedItemIds = this.allItemIds.slice(0);
                this.sandbox.emit(&#x27;husky.datagrid.all.select&#x27;, this.selectedItemIds);
            }
        },

        /**
         * Adds a row to the datagrid
         * @param row
         */
        addRow: function(row) {
            var $table;
            // check for other element types when implemented
            $table = this.$element.find(&#x27;table&#x27;);
            $table.append(this.prepareTableRow(row));
        },

        /**
         * Prepares for removing a row
         * Raises the husky.datagrid.row.remove-click event when auto remove handling is not set to true
         * @param event
         */
        prepareRemoveRow: function(event) {
            if (!!this.options.autoRemoveHandling) {
                this.removeRow(event);
            } else {
                var $tblRow, id;

                $tblRow = this.sandbox.dom.$(event.currentTarget).parent().parent();
                id = $tblRow.data(&#x27;id&#x27;);

                if (!!id) {
                    this.sandbox.emit(&#x27;husky.datagrid.row.remove-click&#x27;, event, id);
                } else {
                    this.sandbox.emit(&#x27;husky.datagrid.row.remove-click&#x27;, event, $tblRow);
                }
            }
        },

        /**
         * Removes a row from the datagrid
         * Raises husky.datagrid.row.removed event
         * @param event
         */
        removeRow: function(event) {

            var $element, $tblRow, id, idx;

            if (typeof event === &#x27;object&#x27;) {

                $element = this.sandbox.dom.$(event.currentTarget);
                $tblRow = $element.parent().parent();

                id = $tblRow.data(&#x27;id&#x27;);
            } else {
                id = event;
                $tblRow = this.$element.find(&#x27;tr[data-id=&quot;&#x27; + id + &#x27;&quot;]&#x27;);
            }

            idx = this.selectedItemIds.indexOf(id);

            if (idx &gt;= 0) {
                this.selectedItemIds.splice(idx, 1);
            }

            this.sandbox.emit(&#x27;husky.datagrid.row.removed&#x27;, event);
            $tblRow.remove();
        },

        // TODO: create pagination module
        /**
         * Appends pagination when option is set
         * @returns {*}
         */
        appendPagination: function() {

            // TODO adjust when api is finished
            if (this.options.pagination &amp;&amp; !!this.data.links) {
                this.$element.append(this.preparePagination());
            }
            return this;
        },

        /**
         * Delegates the rendering of the pagination when paginations is needed
         * @returns {*}
         */
        preparePagination: function() {
            var $pagination;

            if (!!this.options.pagination &amp;&amp; parseInt(this.data.pages, 10) &gt; 1) {
                $pagination = this.sandbox.dom.$(&#x27;&lt;div/&gt;&#x27;);
                $pagination.addClass(&#x27;pagination&#x27;);

                // TODO next / prev not set when on last / first page
                $pagination.append(this.preparePaginationForwardNavigation());
                $pagination.append(this.preparePaginationPageNavigation());
                $pagination.append(this.preparePaginationBackwardNavigation());
            }

            return $pagination;
        },

        /**
         * Triggers rendering of the numbers in the pagination
         * @returns {*}
         */
        preparePaginationPageNavigation: function() {
            return this.templates.paginationPageNavigation({
                pageSize: this.data.pageSize,
                pages: this.data.pages,
                page: this.data.page,
                pagesDisplay: this.data.pageDisplay
            });
        },

        /**
         * Triggers rendering for last and next link
         * @returns {*|string}
         */
        preparePaginationBackwardNavigation: function() {

            var $next = &#x27;&#x27;,
                $last = &#x27;&#x27;;

            if(this.data.links.next) {
                $next = this.templates.paginationNavigation(&quot;next&quot;, &quot;Next&quot;);
            }
            if(this.data.links.last) {
                $last = this.templates.paginationNavigation(&quot;last&quot;, &quot;&quot;);
            }

            return [&quot;&lt;ul&gt;&quot;,$next,$last,&quot;&lt;/ul&gt;&quot;].join(&#x27;&#x27;);
        },


        /**
         * Triggers rendering for first and previous link
         * @returns {*|string}
         */
        preparePaginationForwardNavigation: function() {
            var $prev = &#x27;&#x27;,
                $first = &#x27;&#x27;;

            if(this.data.links.first) {
                $first = this.templates.paginationNavigation(&quot;first&quot;, &quot;&quot;);
            }
            if(this.data.links.prev) {
                $prev = this.templates.paginationNavigation(&quot;prev&quot;, &quot;Previous&quot;);
            }

            return [&quot;&lt;ul&gt;&quot;,$first,$prev,&quot;&lt;/ul&gt;&quot;].join(&#x27;&#x27;);
        },

        /**
         * Called when the current page should change
         * Emits husky.datagrid.updated event on success
         * @param event
         */
        changePage: function(event) {

            var $element, page, template, url, uri;

            $element = this.sandbox.dom.$(event.currentTarget);
            page = $element.data(&#x27;page&#x27;);

            if(!!page) {
                this.addLoader();
                this.resetItemSelection();
                //this.resetSortingOptions(); // browsing through sorted pages
                
                this.sandbox.emit(&#x27;husky.datagrid.page.change&#x27;, &#x27;change page&#x27;);

                uri = this.data.links[page];

                if(!!uri) {
                    url = uri;
                } else {
                    template = this.sandbox.uritemplate.parse(this.data.links.pagination);
                    url = this.sandbox.uritemplate.expand(template, {page: page});
                }

                this.load({
                    url: url,
                    page: page,
                    success: function() {
                        this.removeLoader();
                        this.sandbox.emit(&#x27;husky.datagrid.updated&#x27;, &#x27;updated page&#x27;);
                    }.bind(this)
                });
            }
        },

        resetSortingOptions: function() {
            this.sort.attribute = null;
            this.sort.direction = null;
        },

        bindDOMEvents: function() {

            if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;checkbox&#x27;) {
                this.$element.on(&#x27;click&#x27;, &#x27;tbody &gt; tr span.custom-checkbox-icon&#x27;, this.selectItem.bind(this));
                this.$element.on(&#x27;change&#x27;, &#x27;tbody &gt; tr input[type=&quot;checkbox&quot;]&#x27;, this.selectItem.bind(this));
                this.$element.on(&#x27;click&#x27;, &#x27;th.select-all&#x27;, this.selectAllItems.bind(this));
            } else if (!!this.options.selectItem.type &amp;&amp; this.options.selectItem.type === &#x27;radio&#x27;) {
                this.$element.on(&#x27;click&#x27;, &#x27;tbody &gt; tr input[type=&quot;radio&quot;]&#x27;, this.selectItem.bind(this));
            }

            this.$element.on(&#x27;click&#x27;, &#x27;tbody &gt; tr&#x27;, function(event) {
                if (!this.sandbox.dom.$(event.target).is(&#x27;input&#x27;) &amp;&amp; !this.sandbox.dom.$(event.target).is(&#x27;span.icon-remove&#x27;)) {
                    var id = this.sandbox.dom.$(event.currentTarget).data(&#x27;id&#x27;);

                    if (!!id) {
                        this.sandbox.emit(&#x27;husky.datagrid.item.click&#x27;, id);
                    } else {
                        this.sandbox.emit(&#x27;husky.datagrid.item.click&#x27;, event);
                    }
                }
            }.bind(this));

            if (this.options.pagination) {
                this.$element.on(&#x27;click&#x27;, &#x27;.pagination li.page&#x27;, this.changePage.bind(this));
            }

            if (this.options.removeRow) {
                this.$element.on(&#x27;click&#x27;, &#x27;.remove-row &gt; span&#x27;, this.prepareRemoveRow.bind(this));
            }

            if (this.options.sortable) {
                this.$element.on(&#x27;click&#x27;, &#x27;thead th[data-attribute]&#x27;, this.changeSorting.bind(this));
            }


            // Todo
            // trigger event when click on clickable area
            // different handling when clicked on checkbox and when clicked on td

            // if (this.options.selectItem &amp;&amp; !this.options.selectItem.clickable)
            //     this.$element.on(&#x27;click&#x27;, &#x27;tbody tr td:first-child()&#x27;, function(event) {

            //         // change checked state
            //         var $input = this.sandbox.dom.$(event.target).find(&quot;input&quot;);
            //         $input.prop(&quot;checked&quot;, !$input.prop(&quot;checked&quot;));

            //         itemId = this.sandbox.dom.$(event.target).parents(&#x27;tr&#x27;).data(&#x27;id&#x27;);

            // if(!!itemId){
            //     this.selectedItemIds.push(itemId);
            //     this.sandbox.once(&#x27;husky.datagrid.item.select&#x27;, itemId);
            // } else {
            //     this.sandbox.once(&#x27;husky.datagrid.item.select&#x27;, event);
            // }

            // stop propagation
            //         event.stopPropagation();
            // }.bind(this));
        },

        /**
         * Sets header classes and loads new data
         * Emits husky.datagrid.updated event on success
         * @param event
         */
        changeSorting: function(event) {

            var attribute = this.sandbox.dom.data(event.currentTarget, &#x27;attribute&#x27;),
                $element = event.currentTarget,
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0],
                url, template;

            if (!!attribute &amp;&amp; !!this.data.links.sortable[attribute]) {

                this.sandbox.emit(&#x27;husky.datagrid.data.sort&#x27;);
                this.sort.attribute = attribute;

                if (this.sandbox.dom.hasClass($span, this.sort.ascClass)) {
                    this.sort.direction = &quot;desc&quot;;
                } else {
                    this.sort.direction = &quot;asc&quot;;
                }

                this.addLoader();
                template = this.sandbox.uritemplate.parse(this.data.links.sortable[attribute]);
                url = this.sandbox.uritemplate.expand(template, {sortOrder: this.sort.direction});

                this.load({
                    url: url,
                    success: function () {
                        this.removeLoader();
                        this.sandbox.emit(&#x27;husky.datagrid.updated&#x27;, &#x27;updated sort&#x27;);
                    }.bind(this)
                });
            }
        },

        /**
         * Sets the header classes used for sorting purposes
         * needs this.sort to be correctly initialized
         */
        setHeaderClasses: function() {
            var attribute = this.sort.attribute,
                direction = this.sort.direction,
                $element = this.sandbox.dom.find(&#x27;thead th[data-attribute=&#x27; + attribute + &#x27;]&#x27;, this.$element),
                $span = this.sandbox.dom.children($element, &#x27;span&#x27;)[0];

            if (!!attribute) {

                this.sandbox.dom.addClass($element, &#x27;bold&#x27;);

                if (direction === &#x27;asc&#x27;) {
                    this.sandbox.dom.addClass($span, this.sort.ascClass + this.sort.additionalClasses);
                } else {
                    this.sandbox.dom.addClass($span, this.sort.descClass + this.sort.additionalClasses);
                }

            }
        },

        bindCustomEvents: function() {

            // listen for private events
            this.sandbox.on(&#x27;husky.datagrid.update&#x27;, this.updateHandler.bind(this));

            // listen for public events
            this.sandbox.on(&#x27;husky.datagrid.row.add&#x27;, this.addRow.bind(this));

            this.sandbox.on(&#x27;husky.datagrid.row.remove&#x27;, this.removeRow.bind(this));

            // trigger selectedItems
            this.sandbox.on(&#x27;husky.datagrid.items.get-selected&#x27;, this.getSelectedItemsIds.bind(this));

            this.sandbox.on(&#x27;husky.datagrid.data.get&#x27;, this.provideData.bind(this));
        },

        provideData: function() {
            this.sandbox.emit(&#x27;husky.datagrid.data.provide&#x27;, this.data);
        },

        /**
         * Updates data in datagrid
         * Called when husky.datagrid.update event emitted
         * Emits husky.datagrid.updated event on success
         */
        updateHandler: function() {
            this.resetItemSelection();
            this.resetSortingOptions();

            // TODO does not work?
            this.load({
                url: this.data.links.self,
                success: function () {
                    this.removeLoader();
                    this.sandbox.emit(&#x27;husky.datagrid.updated&#x27;, &#x27;updated data 123&#x27;);
                }.bind(this)
            });
        },

        /**
         * Renders datagrid element in container
         * Binds DOM events
         */
        render: function() {
            this.$originalElement.html(this.$element);
            this.bindDOMEvents();
        },

        /**
         * Adds loading icon and keeps width and height
         * @returns {*}
         */
        addLoader: function() {
            return this.$element
                .outerWidth(this.$element.outerWidth())
                .outerHeight(this.$element.outerHeight())
                .empty()
                .addClass(&#x27;is-loading&#x27;);
        },

        /**
         * Removes loading icon, width and height of container
         * @returns {*}
         */
        removeLoader: function() {
            return this.$element.removeClass(&#x27;is-loading&#x27;).outerHeight(&quot;&quot;).outerWidth(&quot;&quot;);
        },

        /**
         * Returns selected items either via callback or else via husky.datagrid.items.selected event
         * Gets called on husky.datagrid.items.get-selected event
         * @param callback
         */
        getSelectedItemsIds: function(callback) {
            if (typeof callback === &#x27;function&#x27;) {
                callback(this.selectedItemIds);
            } else {
                this.sandbox.emit(&#x27;husky.datagrid.items.selected&#x27;, this.selectedItemIds);
            }
        },

        templates: {
            removeRow: function() {
                return [
                    &#x27;&lt;span class=&quot;icon-remove&quot;&gt;&lt;/span&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            checkbox: function(data) {
                var id, name;

                data = data || {};
                id = (!!data.id) ? &#x27; id=&quot;&#x27; + data.id + &#x27;&quot;&#x27; : &#x27;&#x27;;
                name = (!!data.name) ? &#x27; name=&quot;&#x27; + data.name + &#x27;&quot;&#x27; : &#x27;&#x27;;

                return [
                    &#x27;&lt;input&#x27;, id, name, &#x27; type=&quot;checkbox&quot; class=&quot;custom-checkbox&quot;/&gt;&#x27;,
                    &#x27;&lt;span class=&quot;custom-checkbox-icon&quot;&gt;&lt;/span&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            radio: function(data) {
                var id, name;

                data = data || {};
                id = (!!data.id) ? &#x27; id=&quot;&#x27; + data.id + &#x27;&quot;&#x27; : &#x27;&#x27;;
                name = (!!data.name) ? &#x27; name=&quot;&#x27; + data.name + &#x27;&quot;&#x27; : &#x27;&#x27;;

                return [
                    &#x27;&lt;input&#x27;, id, name, &#x27; type=&quot;radio&quot; class=&quot;custom-radio&quot;/&gt;&#x27;,
                    &#x27;&lt;span class=&quot;custom-radio-icon&quot;&gt;&lt;/span&gt;&#x27;
                ].join(&#x27;&#x27;);
            },

            // Pagination
            paginationNavigation: function(data , label) {

                return [&#x27;&lt;li class=&quot;pagination-&#x27;,data,&#x27; page&quot; data-page=&quot;&#x27;, data, &#x27;&quot;&gt;&#x27;,label,&#x27;&lt;/li&gt;&#x27;].join(&#x27;&#x27;);
            },


            paginationPageNavigation: function(data) {

                // TODO currect page + this.options.paginationOptions.showPages: 5
                var rest,
                    pageItemsCurrentAfter = [],
                    pageItemsBefore = [],
                    pageClass,
                    i;

                // add pages for current after current page
                for (i = data.page; i &lt;= data.pagesDisplay; i++) {
                    pageClass = (data.page === i) ? &#x27;class=&quot;page is-selected bold&quot;&#x27; : &#x27;class=&quot;page&quot;&#x27;;
                    pageItemsCurrentAfter.push(&#x27;&lt;li &#x27;+pageClass+&#x27; data-page=&quot;&#x27;+ i + &#x27;&quot;&gt;&#x27; + i + &#x27;&lt;/li&gt;&#x27;);
                }


                rest = data.pagesDisplay - pageItemsCurrentAfter.length;

                // add pages before current page if needed
                if(rest &gt; 0) {
                    for (i = data.page-rest; i &lt; data.page ; i++) {
                        pageItemsBefore.push(&#x27;&lt;li class=&quot;page&quot; data-page=&quot;&#x27;+ i + &#x27;&quot;&gt;&#x27; + i + &#x27;&lt;/li&gt;&#x27;);
                    }
                }

                return &#x27;&lt;ul&gt;&#x27;+ pageItemsBefore.join(&#x27;&#x27;) + pageItemsCurrentAfter.join(&#x27;&#x27;) + &#x27;&lt;/ul&gt;&#x27;;
            }
        }

    };

});

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
